<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>lib/eco.js - SimplyEco</title>
    
    <meta name="description" content="Simply Eco is a powerful module that allows you to create economy system in your bot with ease.:)" />
    
        <meta name="keywords" content="simplyeco, mongo-eco.js, economy-mongo, eco, economy, simply-eco" />
        <meta name="keyword" content="simplyeco, mongo-eco.js, economy-mongo, eco, economy, simply-eco" />
    
    
    
    <meta property="og:title" content="SimplyEco Docs"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://i.imgur.com/DWeejI6.png"/>
    <meta property="og:site_name" content="SimplyEco"/>
    <meta property="og:url" content="https://simplyeco.js.org"/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/Xx-Mohit-xX/simply-eco" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h2><a href="https://www.npmjs.com/package/simply-eco" target="_blank" class="menu-item" id="npm" >Npm Info</a></h2><h2><a href="https://discord.gg/NAaxz5PgNn" target="_blank" class="menu-item" id="server" >Support server</a></h2><h3>Classes</h3><ul><li><a href="SimplyEco%2520the%2520constructor.html">SimplyEco the constructor</a></li></ul><h3>Modules</h3><ul><li><a href="module-AddItem.html">AddItem</a></li><li><a href="module-AddMoney.html">AddMoney</a></li><li><a href="module-BuyItem.html">BuyItem</a></li><li><a href="module-Daily.html">Daily</a></li><li><a href="module-Deposit.html">Deposit</a></li><li><a href="module-GetBal.html">GetBal</a></li><li><a href="module-GetBankBal.html">GetBankBal</a></li><li><a href="module-GetInv.html">GetInv</a></li><li><a href="module-GetItem.html">GetItem</a></li><li><a href="module-GetProfile.html">GetProfile</a></li><li><a href="module-GetRich.html">GetRich</a></li><li><a href="module-GetShop.html">GetShop</a></li><li><a href="module-GetUser.html">GetUser</a></li><li><a href="module-ReassignJob.html">ReassignJob</a></li><li><a href="module-RemoveItem.html">RemoveItem</a></li><li><a href="module-RemoveJob.html">RemoveJob</a></li><li><a href="module-RemoveMoney.html">RemoveMoney</a></li><li><a href="module-SellItem.html">SellItem</a></li><li><a href="module-SetDaily.html">SetDaily</a></li><li><a href="module-SetJob.html">SetJob</a></li><li><a href="module-SetWeekly.html">SetWeekly</a></li><li><a href="module-Transfer.html">Transfer</a></li><li><a href="module-Weekly.html">Weekly</a></li><li><a href="module-Withdraw.html">Withdraw</a></li><li><a href="module-Work.html">Work</a></li></ul><h3>Global</h3><ul><li><a href="global.html#SimplyEco">SimplyEco</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/eco.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
/**
 * @fileOverview SimplyEco a powerful module which help to create economy system with ease
 * @requires mongoose
 * @requires discord.js
*/
const mongoose = require('mongoose');
const guildUserData = require('../models/nonGlobal/users');
const guildData = require('../models/nonGlobal/guild');
const globalShop = require('../models/global/global-shop');
const globalUserData = require('../models/global/global-users');
const jobs = require('./data/jobs.js');
const { Client } = require('discord.js');

class SimplyEco {
	/**
   * @name SimplyEco the constructor
   * @description Connecting To The Database
   * @class
   * constructs SimplyEco
   * @throws {TypeError} Error while connection to mongoose 
   * @example
   * const economy = require("simply-eco")
   * client.eco = new economy.eco(client, dbUrl, { global: true | false, notify: true | false })
	 */
	constructor(client, dbUrl, options = {}) {
		if (!client) throw new TypeError("No client provided.")
		if (!(client instanceof Client)) throw new TypeError("Provided discord.js client is not right")
		if (!dbUrl) throw new TypeError('dbUrl was not provided!');
		/**
		* @param {string} dbUrl - the mongoose database url
	 * @param {Object[]} options - the options for constructor
	 * @param {Client} client - the discord.js client
	 */
		this.token = dbUrl;
		this.Client = client;
		this.options = options;
		mongoose.connect(
			this.token,
			{
				useNewUrlParser: true,
				useUnifiedTopology: true
			}
		)
			.then(connection => {
				this.connected = true;
				this.mongoClient = connection;
		/**
		* @param {Object[]} options - the options for constructor
	 * @param {boolean} options[].notify - notification toggle for simplyeco
	 */
				if (options.notify === false) return;
				else return console.log("\x1b[32m%s\x1b[0m", "[INFO] SimplyEco connected to Database");
			})
			.catch(e => {
				throw new TypeError(`An Error Just Occurred. ${e.stack}`);
			});
	}
	/**
	 * @name SetWeekly
	 * @module
	 * @description Set a weekly amount for a guild or global. GuildID is not needed for global use.
	 * @example
	 * await client.ecoSetWeekly({ GuildID: "881789379553656872", Amt: 10000 })
   * @returns {number} the weekly amount
	 */

	async SetWeekly({ GuildID, Amt }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A GuildID must be specified');
			if (!Amt) throw new TypeError('An Amount to give must be specified.');
			if (isNaN(Amt)) throw new TypeError("Amount must be in number")
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			let GuildData = await guildData.findOne({
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {number} Amt
			 */			
			if (!GuildData) {
				let Add = new guildData({
					gid: GuildID,
					weeklyAmt: Number(Amt)
				});
				await Add.save();
			}
			/**
			 * The amount to set
			 * @param {number} Amt
			 */
			GuildData.weeklyAmt = Number(Amt);
			GuildData.save();
			return GuildData.weeklyAmt;
		} else {
			if (!Amt) throw new TypeError('A Amount to exchange must be specified.');
			if (isNaN(Amt)) throw new TypeError("Amount must be in number")
			let globalData = await globalShop.findOne({
				Id: this.Client.user.id,
			});
			/**
			 * The amount to set
			 * @param {number} Amt
			 */			
			if (!globalData) {
				let Add = new globalShop({
					gid: this.Client.user.id,
					weeklyAmt: Number(Amt)
				});
				await Add.save();
			}
			/**
			 * The amount to set
			 * @param {number} Amt
			 */			
			globalData.weeklyAmt = Number(Amt);
			globalData.save();
			return globalData.weeklyAmt;
		}
	}

	/**
	 * @name SetDaily
	 * @module
	 * @description Set a daily amount for a guild or global. GuildID is not needed for global use.
	 * @example
	 * await client.ecoSetDaily({ GuildID: "881789379553656872", Amt: 10000 })
   * @returns {number} the daily amt 
	 */
	async SetDaily({ GuildID, Amt }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A GuildID must be specified'); 
			if (!Amt) throw new TypeError('An Amount to give must be specified.');
			if (isNaN(Amt)) throw new TypeError("Amt must be in number")
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			let GuildData = await guildData.findOne({
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {number} Amt
			 */			
			if (!GuildData) {
				let Add = new guildData({
					gid: GuildID,
					dailyAmt: Number(Amt)
				});
				await Add.save();
			}
			/**
			 * The amount to set
			 * @param {number} Amt
			 */
			GuildData.dailyAmt = Number(Amt);
			GuildData.save();
			return GuildData.dailyAmt;
		} else {
			if (!Amt) throw new TypeError('A Amount to exchange must be specified.');
			if (isNaN(Amt)) throw new TypeError("Amt must be in number")
			let globalData = await globalShop.findOne({
				Id: this.Client.user.id
			});
			/**
			 * The amount to set
			 * @param {number} Amt
			 */
			if (!globalData) {
				let Add = new globalShop({
					Id: this.Client.user.id,
					dailyAmt: Number(Amt)
				});
				await Add.save();
			}
			/**
			 * The amount to set
			 * @param {number} Amt
			 */			
			globalData.dailyAmt = Number(Amt);
			globalData.save();
			return globalData.dailyAmt;
		}
	}

	/**
	 * @name Transfer
	 * @module
	 * @description Transfer money over 2 people. GuildID property is not needed for global use.
   * @example
   * await client.ecoTransfer({ GuildID: "881789379553656872", Amt: 10000, User1ID: "777474453114191882", User2ID: "753974636508741673" })
   * @returns {(string|Object)} return NOT_ENOUGH_CASH or USER1 and USER2 wallet bal
*/
 async Transfer({ GuildID, User1ID, User2ID, Amt }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			if (!User1ID) throw new TypeError('A User must be specified.');
			if (!User1ID) throw new TypeError('A User must be specified.');
			if (!Amt) throw new TypeError('A Amount to exchange  must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let User1Data = await guildUserData.findOne({
				gid: GuildID,
				userID: User1ID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let User2Data = await guildUserData.findOne({
				gid: GuildID,
				userID: User2ID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!User1Data) {
				let AddUser = new guildUserData({
					userID: User1ID,
					gid: GuildID
				});

				await AddUser.save();
				return 'NOT_ENOUGH_CASH';
			} else if (!User2Data) {
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 * @param {number} Amt
			 */
				let AddUser = new guildUserData({
					userID: User2ID,
					gid: GuildID,
					wallet: Number(Amt)
				});

				await AddUser.save();
				return AddUser;
			} else {
			/**
			 * The amount to transfer
			 * @param {number} Amt
			 */
				if (User1Data.wallet &lt; Amt) {
					return 'NOT_ENOUGH_CASH';
				}
				User1Data.wallet -= Number(Amt);
				User2Data.wallet += Number(Amt);
				await User1Data.save();
				await User2Data.save();
				return { USER1: User1Data.wallet, USER2: User2Data.wallet };
			}
		} else {
			if (!User1ID) throw new TypeError('A User must be specified.');
			if (!User1ID) throw new TypeError('A User must be specified.');
			if (!Amt) throw new TypeError('A Amount to exchange  must be specified.');
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let User1Data = await globalUserData.findOne({
				userID: User1ID
			});
			/**
			 * The User ID
			 * @param {string} UserID
			 */			
			let User2Data = await globalUserData.findOne({
				userID: User2ID
			});
			if (!User1Data) {
			/**
			 * The User ID
			 * @param {string} UserID
			 */			  
				let AddUser = new globalUserData({
					userID: User1ID,
				});

				await AddUser.save();
				return 'NOT_ENOUGH_CASH';
			} else if (!User2Data) {
			/**
			 * The User ID
			 * @param {string} UserID
			 * @param {number} Amt
			 */			  
				let AddUser = new globalUserData({
					userID: User2ID,
					wallet: Number(Amt)
				});

				await AddUser.save();
				return AddUser;
			} else {
			/**
			 * The amount to transfer
			 * @param {number} Amt
			 */
				if (User1Data.wallet &lt; Amt) {
					return 'NOT_ENOUGH_CASH';
				}
				User1Data.wallet -= Number(Amt);
				User2Data.wallet += Number(Amt);
				await User1Data.save();
				await User2Data.save();
				return { USER1: User1Data.wallet, USER2: User2Data.wallet };
			}
		}

	}

	/**
	 * @module
	 * @name RemoveItem
	 * @description Remove an item from the shop. GuildID is not needed for global use.
	 * @example
	 * await client.ecoRemoveItem({ GuildID: "881789379553656872", Item: "very expensive pancakes" | "0"})
   * @returns {(string|Array)} return NO_ITEM or ITEM_NOT_FOUND or INVALID_ITEM or array of shopItems objects
	 */
	async RemoveItem({ GuildID, Item }) {
		if (!Item) throw new TypeError('A Item Id must be specified.');

		if (this.options?.global === true) {
			let Global = await globalShop.findOne({
				Id: this.Client.user.id
			});
			if (!Global) {
				return 'NO_ITEMS';
			}

			let itemm = await Global.shopItems.filter(item => _checkItem(item, Item));
   if (isNaN(Item)){

			if (!itemm[0]) {
				return 'ITEM_NOT_FOUND';
      } else {
     	/**
			 * The Item name or number
			 * @param {(string|number)} Item
			 */
     const global = Global.shopItems.filter(item => item.Name !== Item)
      
			await Global.save();
      
      }
   } else if (Number(Item)) {

			if (!itemm[0]) {
				return 'ITEM_NOT_FOUND';
      } else {
     	/**
			 * The Item name or number
			 * @param {(string|number)} Item
			 */     
     Global.shopItems.filter(item => item.id !== Item)
    await Global.save();
      }
   } else {
     return "INVALID_ITEM"
   }

			return Global.shopItems;
		} else if (!this.options?.global || this.options?.global === false) {
			if (!GuildID) throw new TypeError('A GuildID must be specified');
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */			
			let GuildData = await guildData.findOne({
				gid: GuildID
			});
			if (!GuildData) {
				return 'NO_ITEMS';
			}
     	/**
			 * The Item name or number
			 * @param {(string|number)} Item
			 */
			let itemm = await Global.shopItems.filter(item => _checkItem(item, Item));

      if (isNaN(Item)){

			if (itemm[0]) {
				return 'ITEM_NOT_FOUND';
      } else {
     	/**
			 * The Item name or number
			 * @param {(string|number)} Item
			 */
     GuildData.shopItems.filter(item => item.Name !== Item)

      }   
  } else if (Number(Item)) {

			if (!itemm[0]) {
				return 'ITEM_NOT_FOUND';
      } else {
     	/**
			 * The Item name or number
			 * @param {(string|number)} Item
			 */
             GuildData.shopItems.filter(item => item.id !== Item)

      }   
      } else {
     return "INVALID_ITEM";
      }

			await GuildData.save();
			return GuildData.shopItems;
		}
	}

	/**
	 * @module
	 * @name AddItem
	 * @description Add an item to a user. GuildID is not needed for global use.
	 * @example
	 * await client.ecoAddItem({ GuildID: "881789379553656872", ItemName: "very expensive pancakes", Price: 10000, SellPrice: 1000 })
   * @returns {Array} return array of shopItems objects
	 */
	async AddItem({ GuildID, ItemName, Price, SellPrice }) {
		if (!ItemName) throw new TypeError('A Item Name must be specified.');
		if (!Price) throw new TypeError('A Price must be specified');
    if(isNaN(Price)) throw new TypeError('Price must be in number');
		if (!SellPrice) throw new TypeError('A SellPrice  must be specified.');
    if(isNaN(SellPrice)) throw new TypeError('SellPrice must be in number');

		let GuildData = await guildData.findOne({
			gid: GuildID
		});
		let Global = await globalShop.findOne({
			Id: this.Client.user.id
		});

		if (this.options.global === true) {

			if (!Global) {
				let Add2 = new globalShop({
					userID: this.Client.user.id
				});
				/**
				 * @param {string} ItemName - the item name
				 * @param {number} Price - the price of item
				 * @param {number} SellPrice - the selling price
				 */
				let Item = { Name: ItemName, Price: Price, Sell: SellPrice, id: 0 };
				Add2.shopItems.push(Item);
				await Add2.save();
				return Add2;
			}
			/**
			 * @param {string} ItemName - the item name
			 * @param {number} Price - the price of item
			 * @param {number} SellPrice - the selling price
			 */
			let Item = {
				Name: ItemName,
				Price: Price,
				Sell: SellPrice,
				id: Global.shopItems.length
			};
			Global.shopItems.push(Item);
			await Global.save();
			return Global.shopItems;
		} else if (!this.options?.global || this.options.global === false) {
			if (!GuildID) throw new TypeError('A GuildID must be specified');
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			if (!GuildData) {
				let Add = new guildData({
					gid: GuildID
				});
			/**
			 * @param {string} ItemName - the item name
			 * @param {number} Price - the price of item
			 * @param {number} SellPrice - the selling price
			 */
				let Item = { Name: ItemName, Price: Price, Sell: SellPrice, id: 0 };
				Add.shopItems.push(Item);
				await Add.save();
				return Add;
			}
			/**
			 * @param {string} ItemName - the item name
			 * @param {number} Price - the price of item
			 * @param {number} SellPrice - the selling price
			 */
			let Item = {
				Name: ItemName,
				Price: Price,
				Sell: SellPrice,
				id: GuildData.shopItems.length
			};
			GuildData.shopItems.push(Item);
			await GuildData.save();
			return GuildData.shopItems;
		}
	}

	/**
	 * @module
	 * @name BuyItem
	 * @description Buy an item to a user. GuildID is not needed for global use.
	 * @example
	 * await client.ecoBuyItem({ GuildID: "881789379553656872", Item: "very expensive pancakes" | "0", user: "753974636508741673" })
   * @returns {(string|Array)} return ITEM_NOT_FOUND or NOT_ENOUGH_CASH or ALREADY_PURCHASED or array of item objects
	 */
	async BuyItem({ UserID, GuildID, Item }) {
		if (!UserID) throw new TypeError('A User ID must be specified');

		if (this.options?.global === true) {
			let Global = await globalShop.findOne({
				Id: this.Client.user.id
			});
			if (!Global) {
				return false;
			}
			/**
			 * Item name or id
			 * @param {(string|number)} Item
			 */
			let item = await Global.shopItems.filter(item => _checkItem(item, Item));
			/**
			 * The User ID
			 * @param {string} UserID
			 */
      let UserData = await globalUserData.findOne({
				userID: UserID
			});

			if (!item[0].Name) {
				return 'ITEM_NOT_FOUND';
			}

			if (UserData.wallet &lt; item[0].Price) {
				return 'NOT_ENOUGH_CASH';
			}
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'NOT_ENOUGH_CASH';
			} else {
				if (UserData.inventory.length === 0) {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
							/**
			 * The Item name or id
			 * @param {(string|number)} Item
			 */
				let item1 = UserData.inventory.find(item => _checkItem(item, Item));

				if (item1) {
					return 'ALREADY_PURCHASED';
				} else {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
			}
		} else if (!this.options.global || this.options.global === false) {
			if (!GuildID) throw new TypeError('A Guild ID must be specified');
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			let Shop = await guildData.findOne({
				gid: GuildID
			});
			if (!Shop) {
				return false;
			}
						/**
			 * The Item name or id 
			 * @param {(string|number)} Item
			 */
			let item = await Shop.shopItems.filter(item => _checkItem(item, Item));
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				gid: GuildID,
				userID: UserID
			});

			if (!item.Name) {
				return 'ITEM_NOT_FOUND';
			}

			if (UserData.wallet &lt; item[0].Price) {
				return 'NOT_ENOUGH_CASH';
			}
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'NOT_ENOUGH_CASH';
			} else {
				if (UserData.inventory.length === 0) {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
				let item1 = UserData.inventory.find(item => _checkItem(item, Item));

				if (item1) {
					return 'ALREADY_PURCHASED';
				} else {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
			}
		}
	}

	/**
	 * @module
	 * @name SellItem
	 * @description Sell an item. GuildID is not needed for global use.
	 * @example
	 * await client.ecoSellItem({ GuildID: "881789379553656872", Item: "very expensive pancakes" | "0", user: "753974636508741673" })
   * @returns {(string|Array)} return TRY_AGAIN or NO_ITEM_IN_INVENTORY or NOT_PURCHASED or NOT_AVAILABLE_IN_SHOP or array of item objects
	 */
	async SellItem({ UserID, GuildID, Item }) {
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!Item) throw new TypeError('A Item Name must be specified');

		if (this.options?.global === true) {
			let Global = await globalShop.findOne({
				Id: this.Client.user.id
			});
			if (!Global) {
				return false;
			}
			/**
			 * The item name or id
			 * @param {(string|number)} Item
			 */
			let itemName = await Global.shopItems.filter(item =>
				_checkItem(item, Item)
			);
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let UserData = await globalUserData.findOne({
				userID: UserID
			});
			if (!UserData) {
				let AddUser = new globalUserData({
					userID: UserID
				});

				await AddUser.save();
				return 'TRY_AGAIN';
			}
			if (UserData.inventory.length === 0) {
				return 'NO_ITEM_IN_INVENTORY';
			}
			let item2 = UserData.inventory.find(item => _checkItem(item, Item));

			if (!item2) {
				return 'NOT_PURCHASED';
			} else if (!itemName[0]) {
				return 'NOT_AVAILABLE_IN_SHOP';
			} else if (
				UserData.inventory.filter(item => item.Name === itemName.Name)
			) {
				UserData.inventory = UserData.inventory.filter(
					item => item.Name != Item
				);

				UserData.wallet += Number(itemName[0].Sell);
				await UserData.save();
				return itemName[0];
			}
		} else if (!this.options?.global || this.options.global === false) {
			if (!GuildID) throw new TypeError('A GuildID must be specified');
			/**
			 * The Guild id
			 * @param {string} GuildID
			 */
			let Shop = await guildData.findOne({
				gid: GuildID
			});
			if (!Shop) {
				return false;
			}
			let itemName = await Shop.shopItems.filter(item =>
				_checkItem(item, Item)
			);
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				gid: GuildID,
				userID: UserID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'TRY_AGAIN';
			}
			if (UserData.inventory.length === 0) {
				return 'NO_ITEM_IN_INVENTORY';
			}
			let item2 = UserData.inventory.find(item => _checkItem(item, Item));

			if (!item2) {
				return 'NOT_PURCHASED';
			} else if (
				UserData.inventory.filter(item => item.Name === itemName.Name)
			) {
				UserData.inventory = UserData.inventory.filter(
					item => item.Name != Item
				);

				UserData.wallet += Number(itemName[0].Sell);
				await UserData.save();
				return itemName[0];
			}
		}
	}

	/**
	 * @module
	 * @name Daily 
	 * @description Collect the daily amount for an user. GuildID is not needed for global use.
	 * @example
	 * await client.ecoDaily({ GuildID: "881789379553656872", UserID: "753974636508741673" })
   * @returns {(string|number)} return ALREADY_USED or user's wallet bal
	 */
	async Daily({ UserID, GuildID }) {
		if (!this.options?.global) {
			if (!UserID) throw new TypeError('A member ID must be specified');
			if (!GuildID) throw new TypeError('A Guild ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let GuildData = await guildData.findOne({
				gid: GuildID
			});
			let AMT;
			if (!GuildData) {
				AMT = 2000;
			} else if (GuildData) {
				AMT = GuildData.dailyAmt;
			}
			
     /** 
       * @constant 
       * @type {number} 
       * @default
      */
			const timeout = 86400000;
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID,
					wallet: Number(AMT),
					lastUsedDaily: Date.now()
				});

				await AddUser.save();
				return AddUser.wallet;
			}
			let daily = UserData.lastUsedDaily;
			if (daily !== null &amp;&amp; timeout - (Date.now() - daily) > 0) {
				return {
					error: 'ALREADY_USED',
					timeout: _msToTime(timeout - (Date.now() - daily))
				};
			} else {
				UserData.wallet += Number(AMT);
				UserData.lastUsedDaily = Date.now();
				await UserData.save();
				return UserData.wallet;
			}
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let UserData = await globalUserData.findOne({
				userID: UserID,
			});
			let globalData = await globalShop.findOne({
				Id: this.Client.user.id
			});

			let AMT;
			if (!globalData) {
				AMT = 5000;
			} else if (globalData) {
				AMT = globalData.dailyAmt;
			}
			 /** 
       * @constant 
       * @type {number} 
       * @default
      */
			const timeout = 86400000;
			if (!UserData) {
				let AddUser = new globalUserData({
					userID: UserID,
					wallet: Number(AMT),
					lastUsedDaily: Date.now()
				});

				await AddUser.save();
				return AddUser.wallet;
			}
			let daily = UserData.lastUsedDaily;
			if (daily !== null &amp;&amp; timeout - (Date.now() - daily) > 0) {
				return {
					error: 'ALREADY_USED',
					timeout: _msToTime(timeout - (Date.now() - daily))
				};
			} else {
				UserData.wallet += Number(AMT);
				UserData.lastUsedDaily = Date.now();
				await UserData.save();
				return UserData.wallet;
			}
		}
	}
	/**
	 * @module
	 * @name Weekly
	 * @example
	 * await client.ecoDaily({ GuildID: "881789379553656872", UserID: "753974636508741673" })
   * @returns {(string|number)} return ALREADY_USED with timeout or user's wallet bal
	 */
	async Weekly({ UserID, GuildID }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A Item ID must be specified');
			if (!UserID) throw new TypeError('A member ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let GuildData = await guildData.findOne({
				gid: GuildID
			});
			let AMT;
			if (!GuildData) {
				AMT = 10000;
			}
			if (GuildData) {
				AMT = GuildData.weeklyAmt;
			}
     /** 
       * @constant 
       * @type {number} 
       * @default
      */
			const timeout = 604800000;
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID,
					wallet: Number(AMT),
					lastUsedWeekly: Date.now()
				});

				await AddUser.save();
				return AddUser.wallet;
			}
			let weekly = UserData.lastUsedWeekly;
			if (weekly !== null &amp;&amp; timeout - (Date.now() - weekly) > 0) {
				return {
					error: 'ALREADY_USED',
					timeout: _msToTime(timeout - (Date.now() - weekly))
				};
			} else {
				UserData.wallet += Number(AMT);
				UserData.lastUsedWeekly = Date.now();
				await UserData.save();
				return UserData.wallet;
			}
		} else {
			if (!UserID) throw new TypeError('A member ID must be specified');
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let UserData = await globalUserData.findOne({
				userID: UserID,
			});
			let GuildData = await globalShop.findOne({
				Id: this.Client.user.id
			});
			let AMT;
			if (!GuildData) {
				AMT = 10000;
			}
			if (GuildData) {
				AMT = GuildData.weeklyAmt;
			}
     /** 
       * @constant 
       * @type {number} 
       * @default
      */
			const timeout = 604800000;
			if (!UserData) {
				let AddUser = new globalUserData({
					userID: UserID,
					wallet: Number(AMT),
					lastUsedWeekly: Date.now()
				});

				await AddUser.save();
				return AddUser.wallet;
			}
			let weekly = UserData.lastUsedWeekly;
			if (weekly !== null &amp;&amp; timeout - (Date.now() - weekly) > 0) {
				return {
					error: 'ALREADY_USED',
					timeout: _msToTime(timeout - (Date.now() - weekly))
				};
			} else {
				UserData.wallet += Number(AMT);
				UserData.lastUsedWeekly = Date.now();
				await UserData.save();
				return UserData.wallet;
			}
		}
	}
	/**
	 * @module
	* @name GetInv
	* @description Get an inventory of an user. GuildID is not needed for global use.
	* @example
	* await client.ecoGetInv({ GuildID: "881789379553656872", UserID: "753974636508741673" })
  * @returns {(string|Array)} return NO_ITEM or array of user inventory objects
	*/
	async GetInv({ UserID, GuildID }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			if (!UserID) throw new TypeError('A user ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let User = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!User) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();

				if (!AddUser.inventory) {
					return 'NO_ITEM';
				} else {
					return AddUser.inventory;
				}
			}
			if (!User.inventory) {
				return 'NO_ITEM';
			} else {
				return User.inventory;
			}
		} else {
			if (!UserID) throw new TypeError('A user ID must be specified');
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let User = await globalUserData.findOne({
				userID: UserID,
			});
			if (!User) {
				let AddUser = new globalUserData({
					userID: UserID,
				});

				await AddUser.save();

				if (!AddUser.inventory) {
					return 'NO_ITEM';
				} else {
					return AddUser.inventory;
				}
			}
			if (!User.inventory) {
				return 'NO_ITEM';
			} else {
				return User.inventory;
			}
		}
	}

	/**
	 * @module
	* @name GetUser
	* @description Get an user data of an user. GuildID is not needed for global use.
	* @example
	* await client.ecoGetUser({ GuildID: "881789379553656872", UserID: "753974636508741673" })
  * @returns {Array} return array of user objects
	*/
	async GetUser({ UserID, GuildID }) {
		// Required Parameters
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			if (!UserID) throw new TypeError('A user ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let User = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!User) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();

				return AddUser;
			}
			return User;
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			if (!UserID) throw new TypeError('A user ID must be specified');

			let User = await globalUserData.findOne({
				userID: UserID,
			});
			if (!User) {
				let AddUser = new guildUserData({
					userID: UserID,
				});

				await AddUser.save();

				return AddUser;
			}
			return User;
		}
	}

	 /**
	* @module
	* @name GetBal
	* @description Get an balance of an user. GuildID is not needed for global use
	* @example
	* await client.ecoGetBal({ GuildID: "881789379553656872", UserID: "753974636508741673" })
  * @returns {number} return user's wallet balance	
  */
	async GetBal({ UserID, GuildID }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			if (!UserID) throw new TypeError('A member ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let Bal = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!Bal) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();

				return AddUser.wallet;
			}
			return Bal.wallet;
		} else {
			if (!UserID) throw new TypeError('A member ID must be specified');
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let Bal = await globalUserData.findOne({
				userID: UserID,
			});
			if (!Bal) {
				let AddUser = new globalUserData({
					userID: UserID,
				});

				await AddUser.save();

				return AddUser.wallet;
			}
			return Bal.wallet;
		}
	}
	/**
	* @module
	* @name GetItem
	* @description Get an item data. GuildID is not needed for global use
	* @example
	* await client.ecoGetItem({ GuildID: "881789379553656872", Item: "pancakes" })
  * @returns {Array} return array of item objects
*/
	async GetItem({ GuildID, Item }) {
		if (!Item) throw new TypeError('No item name or id specified.');
		if (this.options.global === true) {
			let Global = await globalShop.findOne({
				Id: this.Client.user.id
			});
			if (!Global) return null;

			return Global.shopItems.filter(item => _checkItem(item, Item))[0];
		} else if (!this.options.global || this.options.global === false) {
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			let GuildData = await guildData.findOne({
				gid: GuildID
			});
			if (!GuildData) return null;
      /**
       * The item name or id
       * @param {(string|number)} Item
       * @returns {Array}
       */
			return GuildData.shopItems.filter(item => _checkItem(item, Item))[0];
		}
	}
	/**
	* @module
	* @name GetBankBal
	* @description Get bank balance of an user. GuildID is not needed for global use.
	* @example
	* await client.ecoGetBankBal({ GuildID: "881789379553656872", UserID: "753974636508741673" })
  * @returns {number} return user's bank bal
	*/
	async GetBankBal({ UserID, GuildID }) {

		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			if (!UserID) throw new TypeError('A member ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let Bal = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!Bal) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();

				return AddUser.bank;
			}
			return Bal.bank;
		} else {
			if (!UserID) throw new TypeError('A member ID must be specified');
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let Bal = await globalUserData.findOne({
				userID: UserID,
			});
			if (!Bal) {
				let AddUser = new globalUserData({
					userID: UserID,
				});

				await AddUser.save();

				return AddUser.bank;
			}
			return Bal.bank;
		}
	}
		/**
	* @module
	* @name GetRich
	* @description Get the richest people. GuildID is not needed for global use.
	* @example
	* await client.ecoGetRich({ GuildID: "881789379553656872", UserID: "753974636508741673" })
  * @returns {Array} return array of user objects
	*/
	async GetRich({ GuildID, UserID }) {
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			const lb = await guildUserData
				.find({
					gid: GuildID
				})
				.sort([['wallet' + 'bank', 'descending']])
				.exec()
				.catch(e => {
					throw new TypeError(`An Error Just Occurred. ${e.stack}`);
				});
			if (lb.length === 0) {
				return 'NO_RICH_PEOPLE';
			}
			return lb;
		} else {
     if (!UserID) throw new TypeError("A user id must be specified")
			/**
			 * The guild ID
			 * @param {string} UserID
			 */
			const lb = await globalUserData
				.find({
					userID: UserID
				})
				.sort([['wallet' + 'bank', 'descending']])
				.exec()
				.catch(e => {
					throw new TypeError(`An Error Just Occurred. ${e.stack}`);
				});
			if (lb.length == 0) {
				return 'NO_RICH_PEOPLE';
			}
			return lb;
    }
	}

	/**
	* @module
	* @name GetProfile
	* @description Get a profile data of an user. GuildID is not needed for global use.
	* @example
	* await client.ecoGetProfile({ GuildID: "881789379553656872", UserID: "753974636508741673" })
  * @returns {Array} return array of profile objects
	*/
	async GetProfile({ GuildID, UserID }) {
		if (!UserID) throw new TypeError('A user id must be specified.');
		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let User = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});

			let Profile = [];
			Profile.push({
				user: User.userID,
				wallet: User.wallet,
				job: User.job,
				bank: User.bank,
				inventory: User.inventory.length,
				salary: User.salary
			});
			return Profile;
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let User = await globalUserData.findOne({
				userID: UserID,
			});

			let Profile = [];
			Profile.push({
				user: User.userID,
				wallet: User.wallet,
				job: User.job,
				bank: User.bank,
				inventory: User.inventory.length,
				salary: User.salary
			});
			return Profile;
		}
	}

/**
  * @module
	* @name AddMoney
	* @description Add money to an user. GuildID is not needed for global use.
	* @example
	* await client.ecoAddMoney({ GuildID: "881789379553656872", UserID: "753974636508741673", Amt: "1000" })
  * @returns {number} return user's wallet bal
	*/
	async AddMoney({ UserID, GuildID, Amt }) {
		// Required Parameters
		if (!UserID) throw new TypeError('A user ID must be specified');
		if (!Amt) throw new TypeError('An amount of money must be specified.');

		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			//Find Data In DB
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			//Create Data If None Is Found
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID,
					wallet: Number(Amt)
				});

				await AddUser.save();

				return AddUser.wallet;
			}
			// Update Wallet
			/**
			 * The amount to add to User
			 * @param {number} Amt
			 */
			UserData.wallet += Number(Amt);

			await UserData.save();

			return UserData.wallet;
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let UserData = await globalUserData.findOne({
				userID: UserID,
			});
			//Create Data If None Is Found
			/**
			 * The amount and User ID
			 * @param {number} Amt
			 * @param {string} UserID
			 */			
			if (!UserData) {
				let AddUser = new globalUserData({
					userID: UserID,
					wallet: Number(Amt)
				});

				await AddUser.save();

				return AddUser.wallet;
			}
			// Update Wallet
			UserData.wallet += Number(Amt);

			await UserData.save();

			return UserData.wallet;
		}
	}

	/**
	* @module
	* @name RemoveMoney
	* @description Remove money to an user. GuildID is not needed for global use.
	* @example
	* await client.ecoAddMoney({ GuildID: "881789379553656872", UserID: "753974636508741673", Amt: 1000 })
  * @returns {(string|number)} return NO_MONEY or NOT_ENOUGH_CASH or user's wallet bal
	*/
	async RemoveMoney({ UserID, GuildID, Amt }) {
		// Required Parameters
		if (!UserID) throw new TypeError('A user ID must be specified');
		if (!Amt) throw new TypeError('An amount of money must be specified.');
		if (isNaN(Amt)) throw new TypeError('Amt should be in number');

		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			//Find Data In DB
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			//If None Is Found
			if (!UserData) {
				return "NO_MONEY";
			}
			if (UserData.wallet &lt; Amt) {
				return 'NOT_ENOUGH_CASH';
			}
			// Update Wallet
			UserData.wallet -= Number(Amt);

			await UserData.save();

			return UserData.wallet;
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let UserData = await globalUserData.findOne({
				userID: UserID,
			});
			//If None Is Found
			if (!UserData) {
				return;
			}
			// Update Wallet
			UserData.wallet -= Number(Amt);

			await UserData.save();

			return UserData.wallet;
		}
	}

	/**
	 * @module
	 * @name Deposit
	 * @description Deposit money to an bank. GuildID is not needed for global use.
	 * @example
	 * await client.ecoDeposit({ GuildID: "881789379553656872", Amt: 10, UserID: "753974636508741673" })
   * @returns {(string|Object)} returns NO_CASH_IN_WALLET or NOT_ENOUGH_CASH or bank and wallet balance
	 */

	async Deposit({ UserID, GuildID, Amt }) {
		if (!UserID) throw new SyntaxError('A user ID must be specified.');
		if (!Amt) throw new SyntaxError('An amount must be specified.');
		if (!this.options?.global) {
			if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let Balance = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!Balance) {
				Balance = await new guildUserData({
					userID: UserID,
					gid: GuildID
				});
				await Balance.save();
				return 'NO_CASH_IN_WALLET';
			}
			if (Balance.wallet &lt; Amt) {
				return 'NOT_ENOUGH_CASH';
			}
			let amt;
      if (Amt.toLocaleLowerCase() === 'all') {
        amt = Balance.wallet
      } else if (Amt.toLocaleLowerCase() === 'max') {
				amt = Balance.wallet;
			} else {
    if (isNaN(Amt)) throw new TypeError('Amount must be in number')
      /**
       * The amount to Deposit
       * @param {number} Amt
       */
				amt = Amt;
			}
			Balance.bank += Number(amt);
			Balance.wallet -= Number(amt);

			await Balance.save();

			return { wallet: Balance.wallet, bank: Balance.bank };
		} else {
			let Balance = await globalUserData.findOne({
				userID: UserID,
			});
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			if (!Balance) {
				Balance = await new globalUserData({
					userID: UserID,
				});
				await Balance.save();
				return 'NO_CASH_IN_WALLET';
			}
			if (Balance.wallet &lt; Amt) {
				return 'NOT_ENOUGH_CASH';
			}
			let amt;
			if (Amt.toLocaleLowerCase() === 'max') {
				amt = Balance.wallet;
			} else if (Amt.toLocaleLowerCase() === "all") {
        amt = Balance.wallet
      } else {
    if (isNaN(Amt)) throw new TypeError('Amount must be in number')
        /**
         * The amount to Deposit
         * @param {number} Amt
         */
				amt = Amt;
			}
			Balance.bank += Number(amt);
			Balance.wallet -= Number(amt);

			await Balance.save();

			return { wallet: Balance.wallet, bank: Balance.bank };
		}
	}
	/**
	 * @module
	 * @name Withdraw
	 * @description Withdraw money from a bank. GuildID is not needed for global use.
	 * @example
	 * await client.ecoWithdraw({ GuildID: "881789379553656872", Amt: 10, UserID: "753974636508741673" })
   * @returns {(string|Object)} return NO_CASH_IN_BANK or NOT_ENOUGH_CASH or bank and wallet balance
	 */
	async Withdraw({ UserID, GuildID, Amt }) {

		if (!UserID) throw new SyntaxError('A member ID must be specified.');
		if (!Amt) throw new SyntaxError('An amount must be specified.');
		if (!this.options?.global) {
			if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let Balance = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!Balance) {
				Balance = await new guildUserData({
					userID: UserID,
					gid: GuildID
				});
				await Balance.save();
				return 'NO_CASH_IN_BANK';
			}
			if (Balance.bank &lt; Amt) {
				return 'NOT_ENOUGH_CASH';
			}

			let amt;
			if (Amt.toLocaleLowerCase() === 'max') {
				amt = Balance.bank;
			} else if (Amt.toLocaleLowerCase() === 'all') {
        amt = Balance.bank;     
      } else {
    if (isNaN(Amt)) throw new TypeError('Amount must be in number')
      /**
       * The amount to deposit
       * @param {number} Amt
       */ 
      amt = Amt;
			}
			Balance.bank -= Number(amt);
			Balance.wallet += Number(amt);

			await Balance.save();

			return { wallet: Balance.wallet, bank: Balance.bank };
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let Balance = await globalUserData.findOne({
				userID: UserID,
			});

			if (!Balance) {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
				Balance = await new globalUserData({
					userID: UserID,
				});
				await Balance.save();
				return 'NO_CASH_IN_BANK';
			}
			if (Balance.bank &lt; Amt) {
				return 'NOT_ENOUGH_CASH';
			}

			let amt;
			if (Amt.toLocaleLowerCase() === 'max') {
				amt = Balance.bank;
			} else if (Amt.toLocaleLowerCase() === 'all') {
        amt = Balance.bank;     
      } else {
    if (isNaN(Amt)) throw new TypeError('Amount must be in number')
      /**
       * The amount to deposit
       * @param {number} Amt
       */
      amt = Amt;
			}
			Balance.bank -= Number(amt);
			Balance.wallet += Number(amt);

			await Balance.save();

			return { wallet: Balance.wallet, bank: Balance.bank };
		}
	}

	/**
	 * @module
	 * @name GetShop
	 * @description Get shop items. GuildID is not needed for global use.
	 * @example
	 * await client.ecoGetShop({ GuildID: "881789379553656872" })
   * @returns {(string|Array)} return NO_ITEM_IN_SHOP or array of objects in shop
	 */
	async GetShop({ GuildID }) {
		// Required Parameters
		if (this.options?.global == true) {
			let Gshop = await globalShop.findOne({
				Id: this.Client.user.id
			});
			if (!Gshop) {
				let Ggshop = new globalShop({
					Id: this.Client.user.id
				});

				await Ggshop.save();
				if (!Ggshop.shopItems) {
					return 'NO_ITEM_IN_SHOP';
				} else {
					return Ggshop.shopItems;
				}
			}
			if (!Gshop.shopItems) {
				return 'NO_ITEM_IN_SHOP';
			} else {
				return Gshop.shopItems;
			}
		} else if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A guild id must be specified.');
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			let User = await guildData.findOne({
				gid: GuildID
			});
			/**
			 * The guild ID
			 * @param {string} GuildID
			 */
			if (!User) {
				let AddUser = new guildUserData({
					gid: GuildID
				});

				await AddUser.save();
				if (!AddUser.shopItems) {
					return 'NO_ITEM_IN_SHOP';
				} else {
					return AddUser.shopItems;
				}
			}
			if (!User.shopItems) {
				return 'NO_ITEM_IN_SHOP';
			} else {
				return User.shopItems;
			}
		}
	}

	/**
	 * @module
	 * @name ReassignJob
	 * @description Reassign a job. GuildID is not needed for global use.
	 * @example
	 * await client.ecoReassignJob({ GuildID: "881789379553656872", UserID: "753974636508741673", Job: "Doctor" })
   * @returns {(string|Array)} return SUCCESS or array of jobs
	 */
	async ReassignJob({ UserID, GuildID, Job }) {
		if (!UserID) throw new TypeError('A user ID must be specified.');
		if (!Job) throw new TypeError('A job must be specified.');
		if (!this.options?.global) {
			if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			const user = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!user) {
				const newUser = new guildUserData({
					userID: UserID,
					gid: GuildID
				});
				return newUser.save();
			}
			/**
			 * The Job Name
			 * @param {string} Job
			 */
			let job = jobs.find(job => job.Name === Job.toLocaleLowerCase());

			let current = user.job;
			if (!current) {
				return 'NOT_WORKING';
			} else if (!job) {
				let Jobss = [];
				jobs.map(x => {
					Jobss.push({
						Name: x.Name,
						Salary: x.Salary
					});
				});
				return Jobss;
			} else if (job.Name) {
				user.job = job.Name;
				user.salary = job.Salary;

				await user.save();

				return 'SUCCESS';
			}
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			const user = await globalUserData.findOne({
				userID: UserID,
			});
				/**
			 * The User ID
			 * @param {string} UserID
			 */
			if (!user) {
				const newUser = new globalUserData({
					userID: UserID,
				});
				return newUser.save();
			}
			/**
			 * The Job Name
			 * @param {string} Job
			 */
			let job = jobs.find(job => job.Name === Job.toLocaleLowerCase());

			let current = user.job;
			if (!current) {
				return 'NOT_WORKING';
			} else if (!job) {
				let Jobss = [];
				jobs.map(x => {
					Jobss.push({
						Name: x.Name,
						Salary: x.Salary
					});
				});
				return Jobss;
			} else if (job.Name) {
				user.job = job.Name;
				user.salary = job.Salary;

				await user.save();

				return 'SUCCESS';
			}
		}
	}

	/**
	 * @module
	 * @name RemoveJob
	 * @description Remove a job. GuildID is not needed for global use.
	 * @example
	 * await client.ecoRemoveJob({ GuildID: "881789379553656872", UserID: "753974636508741673"})
  * @returns {string} return SUCCESS or NO_JOB
	 */

	async RemoveJob({ GuildID, UserID }) {
		if (!UserID) throw new SyntaxError('A user ID must be specified.');

		if (!this.options?.global) {
			if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			const user = await guildUserData.findOne({ userID: UserID, gid: GuildID });
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!user) {
				const newUser = new guildUserData({ userID: UserID, gid: GuildID });
				return await newUser.save();
			}

			let current = user.job;

			if (!current) {
				return 'NO_JOB';
			} else if (current) {
				user.job = null;
				await user.save();
				return 'SUCCESS';
			}
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			const user = await globalUserData.findOne({ userID: UserID });
			if (!user) {
				const newUser = new globalUserData({ userID: UserID, gid: GuildID });
				return await newUser.save();
			}

			let current = user?.job;

			if (!current) {
				return 'NO_JOB';
			} else if (current) {
				user.job = null;
				await user.save();
				return 'SUCCESS';
			}
		}
	}

	/**
	 * @module
	 * @name SetJob
	 * @description Set a job. GuildID is not needed for global use.
	 * @example
	 * await client.ecoSetJob({ GuildID: "881789379553656872", UserID: "753974636508741673", Job: "gamer"})
   * @returns {(string|Array)} return SUCCESS or array of jobs
	 */

	async SetJob({ UserID, GuildID, Job }) {
		if (!UserID) throw new SyntaxError('A user ID must be specified.');
		if (!Job) throw new SyntaxError('An amount must be specified.');
		if (!this.options?.global) {
			if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			const user = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */			
			if (!user) {
				const aa = new guildUserData({
					userID: UserID,
					gid: GuildID
				});
				return aa.save();
			}
			/**
			 * The Job Name
			 * @param {string} Job
			 */
			let job = jobs.find(job => job.Name === Job.toLocaleLowerCase());
			let current = user.job;
			if (current) {
				return 'ALREADY_WORKING';
			} else if (!job) {
				let Jobss = [];
				jobs.map(x => {
					Jobss.push({
						Name: x.Name,
						Salary: x.Salary
					});
				});
				return Jobss;
			} else if (job.Name) {
				user.job = job.Name;
				user.salary = job.Salary;

				await user.save();

				return 'SUCCESS';
			}
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			const user = await globalUserData.findOne({
				userID: UserID,
			});
			if (!user) {
				const newUser = new globalUserData({
					userID: UserID,
					gid: GuildID
				});
				return newUser.save();
			}
			/**
			 * The Job Name
			 * @param {string} Job
			 */
			let job = jobs.find(job => job.Name === Job.toLocaleLowerCase());
			let current = user.job;
			if (current) {
				return 'ALREADY_WORKING';
			} else if (!job) {
				let Jobss = [];
				jobs.map(x => {
					Jobss.push({
						Name: x.Name,
						Salary: x.Salary
					});
				});
				return Jobss;
			} else if (job.Name) {
				user.job = job.Name;
				user.salary = job.Salary;

				await user.save();

				return 'SUCCESS';
			}
		}
	}

	/**
	 * @module
	 * @name Work
	 * @description Work for an user. GuildID is not needed for global use.
	 * @example
	 * await client.ecoWork({ GuildID: "881789379553656872", UserID: "753974636508741673" })
   * @returns {(string|Array)} return NO_JOB or ALREADY_WORKING with time remaining or array of object 
	 */
	async Work({ UserID, GuildID }) {
		if (!UserID) throw new TypeError('A member ID must be specified');

		if (!this.options?.global) {
			if (!GuildID) throw new TypeError('A Item ID must be specified');
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			let UserData = await guildUserData.findOne({
				userID: UserID,
				gid: GuildID
			});
			let AMT = UserData.salary;
			
     /** 
       * @constant 
       * @type {number} 
       * @default
      */
			const timeout = 7200000;
			/**
			 * The guild ID and User ID
			 * @param {string} GuildID
			 * @param {string} UserID
			 */
			if (!UserData) {
				let AddUser = new guildUserData({
					userID: UserID,
					gid: GuildID,
					wallet: Number(AMT),
					lastUsedWork: Date.now()
				});

				await AddUser.save();
				return AddUser.wallet;
			}

			let work = UserData.lastUsedWork;
			if (!UserData.job) {
				return 'NO_JOB';
			}
			if (work !== null &amp;&amp; timeout - (Date.now() - work) > 0) {
				return {
					error: 'ALREADY_WORKED',
					timeout: _msToTime(timeout - (Date.now() - work))
				};
			} else {
				UserData.wallet += Number(AMT);
				UserData.lastUsedWork = Date.now();
				await UserData.save();
				return {
					wallet: UserData.wallet,
					timeout: _msToTime(work),
					job: UserData.job,
					salary: AMT
				};
			}
		} else {
			/**
			 * The User ID
			 * @param {string} UserID
			 */
			let UserData = await globalUserData.findOne({
				userID: UserID,
			});
			let AMT = UserData.salary;

     /** 
       * @constant 
       * @type {number} 
       * @default
      */
			const timeout = 7200000;
			/**
			 * The Job Name
			 * @param {string} Job
			 */
			if (!UserData) {
				let AddUser = new globalUserData({
					userID: UserID,
					wallet: Number(AMT),
					lastUsedWork: Date.now()
				});

				await AddUser.save();
				return AddUser.wallet;
			}

			let work = UserData.lastUsedWork;
			if (!UserData.job) {
				return 'NO_JOB';
			}
			if (work !== null &amp;&amp; timeout - (Date.now() - work) > 0) {
				return {
					error: 'ALREADY_WORKED',
					timeout: _msToTime(timeout - (Date.now() - work))
				};
			} else {
				UserData.wallet += Number(AMT);
				UserData.lastUsedWork = Date.now();
				await UserData.save();
				return {
					wallet: UserData.wallet,
					timeout: _msToTime(work),
					job: UserData.job,
					salary: AMT
				};
			}
		}
	}
}

function _msToTime(duration) {
	const ms = Math.floor((duration % 1000) / 100),
		seconds = Math.floor((duration / 1000) % 60),
		minutes = Math.floor((duration / (1000 * 60)) % 60),
		hours = Math.floor((duration / (1000 * 60 * 60)) % 24),
		days = Math.floor((duration / (1000 * 60 * 60 * 24)) % 30);

	const day = days &lt; 10 ? '0' + days : days;
	const hour = hours &lt; 10 ? '0' + hours : hours;
	const minute = minutes &lt; 10 ? '0' + minutes : minutes;
	const second = seconds &lt; 10 ? '0' + seconds : seconds;

	return (
		day + ' Days : ' + hour + ' Hrs : ' + minute + ' Min : ' + second + ' Sec.'
	);
}

const _checkItem = (item, testableItemIdOrName) => {
	return item.Name == testableItemIdOrName || item.id == testableItemIdOrName;
};

module.exports = SimplyEco;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Sat Dec 25 2021 08:42:50 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
