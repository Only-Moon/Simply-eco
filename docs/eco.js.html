<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>eco.js - SimplyEco</title>
    
    <meta name="description" content="A powerful module that allows you to create economy system in your bot with ease." />
    
        <meta name="keywords" content="simplyeco, mongo-eco.js, economy-mongo, eco, economy, simply-eco" />
        <meta name="keyword" content="simplyeco, mongo-eco.js, economy-mongo, eco, economy, simply-eco" />
    
    
    
    <meta property="og:title" content="SimplyEco Docs"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://i.imgur.com/DWeejI6.jpg"/>
    <meta property="og:site_name" content="SimplyEco"/>
    <meta property="og:url" content="https://Xx-Mohit-xX.github.io/simply-eco/"/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/Xx-Mohit-xX/simply-eco" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="SimplyEco.html">SimplyEco</a><ul class='methods'><li data-type='method'><a href="SimplyEco.html#AddItem">AddItem</a></li><li data-type='method'><a href="SimplyEco.html#AddMoney">AddMoney</a></li><li data-type='method'><a href="SimplyEco.html#BuyItem">BuyItem</a></li><li data-type='method'><a href="SimplyEco.html#Daily">Daily</a></li><li data-type='method'><a href="SimplyEco.html#Deposit">Deposit</a></li><li data-type='method'><a href="SimplyEco.html#GetBal">GetBal</a></li><li data-type='method'><a href="SimplyEco.html#GetBankBal">GetBankBal</a></li><li data-type='method'><a href="SimplyEco.html#GetInv">GetInv</a></li><li data-type='method'><a href="SimplyEco.html#GetItem">GetItem</a></li><li data-type='method'><a href="SimplyEco.html#GetProfile">GetProfile</a></li><li data-type='method'><a href="SimplyEco.html#GetRich">GetRich</a></li><li data-type='method'><a href="SimplyEco.html#GetShop">GetShop</a></li><li data-type='method'><a href="SimplyEco.html#GetUser">GetUser</a></li><li data-type='method'><a href="SimplyEco.html#ReassignJob">ReassignJob</a></li><li data-type='method'><a href="SimplyEco.html#RemoveItem">RemoveItem</a></li><li data-type='method'><a href="SimplyEco.html#RemoveJob">RemoveJob</a></li><li data-type='method'><a href="SimplyEco.html#RemoveMoney">RemoveMoney</a></li><li data-type='method'><a href="SimplyEco.html#SellItem">SellItem</a></li><li data-type='method'><a href="SimplyEco.html#SetDaily">SetDaily</a></li><li data-type='method'><a href="SimplyEco.html#SetJob">SetJob</a></li><li data-type='method'><a href="SimplyEco.html#SetWeekly">SetWeekly</a></li><li data-type='method'><a href="SimplyEco.html#Transfer">Transfer</a></li><li data-type='method'><a href="SimplyEco.html#Weekly">Weekly</a></li><li data-type='method'><a href="SimplyEco.html#Withdraw">Withdraw</a></li><li data-type='method'><a href="SimplyEco.html#Work">Work</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">eco.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Mongoose = require('mongoose');
const data = require('../models/users');
const Guildd = require('../models/guild');
const gshop = require('../models/global-shop');
const jobs = require('./data/jobs.js');

class SimplyEco {
	/**
	 * Connecting To The Database
	 *@param dbUrl
	 *@param options
	 */
	constructor(dbUrl, options = {}) {
		if (!dbUrl) throw new TypeError('dbUrl was not provided!');
		this.token = dbUrl;
		Mongoose.connect(
			this.token,
			{
				useNewUrlParser: true,
				useUnifiedTopology: true
			}
		)
			.then(connection => {
				this.connected = true;
				this.mongoClient = connection;
				if (options.notify === false) return;
				else return console.log("\x1b[32m%s\x1b[0m", "[INFO] SimplyEco connected to Database");
			})
			.catch(e => {
				throw new TypeError(`An Error Just Occurred. ${e}`);
			});
	}
	/**
	 * SetWeekly
	 * @param GuildID
	 * @param Amt
	 */
	async SetWeekly(GuildID, Amt) {
		if (!GuildID) throw new TypeError('A GuildID must be specified');
		if (!Amt) throw new TypeError('A Amount to exchange  must be specified.');

		let GuildData = await Guildd.findOne({
			gid: GuildID
		});
		if (!GuildData) {
			let Add = new Guildd({
				gid: GuildID,
				weeklyAmt: Number(Amt)
			});
			await Add.save();
		}
		GuildData.weeklyAmt = Number(Amt);
		GuildData.save();
		return GuildData;
	}

	/**
	 * SetDaily
	 * @param GuildID
	 * @param Amt
	 */
	async SetDaily(GuildID, Amt) {
		if (!GuildID) throw new TypeError('A GuildID must be specified');
		if (!Amt) throw new TypeError('A Amount to exchange  must be specified.');

		let GuildData = await Guildd.findOne({
			gid: GuildID
		});
		if (!GuildData) {
			let Add = new Guildd({
				gid: GuildID,
				dailyAmt: Number(Amt)
			});
			await Add.save();
		}
		GuildData.dailyAmt = Number(Amt);
		GuildData.save();
		return GuildData;
	}

	/**
	 * Transfer
	 * @param GuildID
	 * @param User1ID ID
	 * @param User2ID ID
	 * @param Amt
	 */
	async Transfer(GuildID, User1ID, User2ID, Amt) {
		if (!GuildID) throw new TypeError('A GuildID must be specified');
		if (!User1ID) throw new TypeError('A User  must be specified.');
		if (!User1ID) throw new TypeError('A User  must be specified.');
		if (!Amt) throw new TypeError('A Amount to exchange  must be specified.');
		let User1Data = await data.findOne({
			gid: GuildID,
			userID: User1ID
		});
		let User2Data = await data.findOne({
			gid: GuildID,
			userID: User2ID
		});
		if (!User1Data) {
			let AddUser = new data({
				userID: User1ID,
				gid: GuildID
			});

			await AddUser.save();
			return 'NOT_ENOUGH_CASH';
		} else if (!User2Data) {
			let AddUser = new data({
				userID: User2ID,
				gid: GuildID,
				wallet: Number(Amt)
			});

			await AddUser.save();
			return AddUser;
		} else {
			if (User1Data.wallet &lt; Amt) {
				return 'NOT_ENOUGH_CASH';
			}
			User1Data.wallet -= Number(Amt);
			User2Data.wallet += Number(Amt);
			await User1Data.save();
			await User2Data.save();
			return { USER1: User1Data, USER2: User2Data };
		}
	}

	/**
	 * RemoveItem
	 * param Client
	 * @param GuildID
	 * @param ItemName NAME
	 */
	async RemoveItem(Client, GuildID, Item, options = {}) {
		if (!Item) throw new TypeError('A Item Id must be specified.');
		let GuildData = await Guildd.findOne({
			gid: GuildID
		});
		let Global = await gshop.findOne({
			Id: Client.user.id
		});

		if (options.global === true) {
			if (!Client) throw new TypeError('A discord.js client must be specified');

			if (!Global) {
				return 'NO_ITEMS';
			}

			Global.shopItems = GuildData.shopItems.filter(
				item => item.id !== Item || item.Name !== Item
			);

			await Global.save();
			return Global;
		} else if (!options.global || options.global === false) {
			if (!GuildID) throw new TypeError('A GuildID must be specified');

			if (!GuildData) {
				return 'NO_ITEMS';
			}

			GuildData.shopItems = GuildData.shopItems.filter(
				item => item.id !== Item || item.Name !== Item
			);

			await GuildData.save();
			return GuildData;
		}
	}

	/**
	 * AddItem
	 * @param Client
	 * @param GuildID
	 * @param ItemName NAME
	 * @param Price PRICE
	 * @param SellPrice SELLING PRICE
	 */
	async AddItem(Client, GuildID, ItemName, Price, SellPrice, options = {}) {
		if (!ItemName) throw new TypeError('A Item Name must be specified.');
		if (!Price) throw new TypeError('A Price must be specified');
		if (!SellPrice) throw new TypeError('A SellPrice  must be specified.');
		let GuildData = await Guildd.findOne({
			gid: GuildID
		});
		let Global = await gshop.findOne({
			Id: Client.user.id
		});

		if (options.global === true) {
			if (!Client) throw new TypeError('A discord.js client must be specified');

			if (!Global) {
				let Add2 = new gshop({
					userID: options.userId
				});
				let Item = { Name: ItemName, Price: Price, Sell: SellPrice, id: 0 };
				Add2.shopItems.push(Item);
				await Add2.save();
				return Add2;
			}
			let Item = {
				Name: ItemName,
				Price: Price,
				Sell: SellPrice,
				id: Global.shopItems.length
			};
			Global.shopItems.push(Item);
			await Global.save();
			return Global;
		} else if (!options.global || options.global === false) {
			if (!GuildID) throw new TypeError('A GuildID must be specified');

			if (!GuildData) {
				let Add = new Guildd({
					gid: GuildID
				});
				let Item = { Name: ItemName, Price: Price, Sell: SellPrice, id: 0 };
				Add.shopItems.push(Item);
				await Add.save();
				return Add;
			}
			let Item = {
				Name: ItemName,
				Price: Price,
				Sell: SellPrice,
				id: GuildData.shopItems.length
			};
			GuildData.shopItems.push(Item);
			await GuildData.save();
			return GuildData;
		}
	}

	/**
	 * BuyItem
	 * @param Client
	 * @param UserID
	 * @param GuildID
	 * @param Item ID ID
	 */
	async BuyItem(Client, UserID, GuildID, Item, options = {}) {
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A Guild ID must be specified');
		let Shop = await Guildd.findOne({
			gid: GuildID
		});

		let Global = await gshop.findOne({
			Id: Client.user.id
		});

		if (options.global === true) {
			if (!Client) throw new TypeError('A discord.js client must be specified');

			if (!Global) {
				return false;
			}
			let item = await Global.shopItems.filter(item => _checkItem(item, Item));

			let UserData = await data.findOne({
				gid: GuildID,
				userID: UserID
			});

			if (!item[0].Name) {
				return 'ITEM_NOT_FOUND';
			}

			if (UserData.wallet &lt; item[0].Price) {
				return 'NOT_ENOUGH_CASH';
			}
			if (!UserData) {
				let AddUser = new data({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'NOT_ENOUGH_CASH';
			} else {
				if (UserData.inventory.length === 0) {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
				let item1 = UserData.inventory.find(item => _checkItem(item, Item));

				if (item1) {
					return 'ALREADY_PURCHASED';
				} else {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
			}
		} else if (!options.global || options.global === false) {
			if (!Shop) {
				return false;
			}
			let item = await Shop.shopItems.filter(item => _checkItem(item, Item));
			let UserData = await data.findOne({
				gid: GuildID,
				userID: UserID
			});

			if (!item.Name) {
				return 'ITEM_NOT_FOUND';
			}

			if (UserData.wallet &lt; item[0].Price) {
				return 'NOT_ENOUGH_CASH';
			}
			if (!UserData) {
				let AddUser = new data({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'NOT_ENOUGH_CASH';
			} else {
				if (UserData.inventory.length === 0) {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
				let item1 = UserData.inventory.find(item => _checkItem(item, Item));

				if (item1) {
					return 'ALREADY_PURCHASED';
				} else {
					UserData.inventory.push(item[0]);
					UserData.wallet -= Number(item[0].Price);
					await UserData.save();
					return item[0];
				}
			}
		}
	}

	/**
	 * SellItem
	 * @param Client
	 * @param UserID
	 * @param GuildID
	 * @param ItemN ID
	 */
	async SellItem(Client, UserID, GuildID, ItemN, options = {}) {
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A GuildID must be specified');
		if (!ItemN) throw new TypeError('A Item Name must be specified');
		if (!Client) throw new TypeError('Q discord.js Client must be specified');

		let Shop = await Guildd.findOne({
			gid: GuildID
		});
		let Global = await gshop.findOne({
			Id: Client.user.id
		});

		if (options.global === true) {
			if (!Global) {
				return false;
			}
			let itemName = await Global.shopItems.filter(item =>
				_checkItem(item, ItemN)
			);
			let UserData = await data.findOne({
				gid: GuildID,
				userID: UserID
			});
			if (!UserData) {
				let AddUser = new data({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'TRY_AGAIN';
			}
			if (UserData.inventory.length === 0) {
				return 'NO_ITEM_IN_INVENTORY';
			}
			let item2 = UserData.inventory.find(item => _checkItem(item, ItemN));

			if (!item2) {
				return 'NOT_PURCHASED';
			} else if (itemName === "[]") {
				return 'NOT_AVAILABLE_IN_SHOP';
			} else if (
				UserData.inventory.filter(item => item.Name === itemName.Name)
			) {
				UserData.inventory = UserData.inventory.filter(
					item => item.Name != ItemN
				);

				UserData.wallet += Number(itemName[0].Sell);
				await UserData.save();
				return itemName[0];
			}
		} else if (!options.global || options.global === false) {
			if (!Shop) {
				return false;
			}
			let itemName = await Shop.shopItems.filter(item =>
				_checkItem(item, ItemN)
			);
			let UserData = await data.findOne({
				gid: GuildID,
				userID: UserID
			});
			if (!UserData) {
				let AddUser = new data({
					userID: UserID,
					gid: GuildID
				});

				await AddUser.save();
				return 'TRY_AGAIN';
			}
			if (UserData.inventory.length === 0) {
				return 'NO_ITEM_IN_INVENTORY';
			}
			let item2 = UserData.inventory.find(item => _checkItem(item, ItemN));
			//console.log(item2.Name)

			if (!item2) {
				return 'NOT_PURCHASED';
			} else if (
				UserData.inventory.filter(item => item.Name === itemName.Name)
			) {
				UserData.inventory = UserData.inventory.filter(
					item => item.Name != ItemN
				);

				UserData.wallet += Number(itemName[0].Sell);
				await UserData.save();
				return itemName[0];
			}
		}
	}

	/**
	 * Daily
	 * @param UserID
	 * @param GuildID
	 */

	async Daily(UserID, GuildID) {
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A Item ID must be specified');

		let UserData = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		let GuildData = await Guildd.findOne({
			gid: GuildID
		});
		let AMT;
		if (!GuildData) {
			AMT = 2000;
		}
		if (GuildData) {
			AMT = GuildData.dailyAmt;
		}
		let timeout = 86400000;
		if (!UserData) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID,
				wallet: Number(AMT),
				lastUsedDaily: Date.now()
			});

			await AddUser.save();
			return AddUser.wallet;
		}
		let daily = UserData.lastUsedDaily;
		if (daily !== null &amp;&amp; timeout - (Date.now() - daily) > 0) {
			return {
				error: 'ALREADY_USED',
				timeout: _msToTime(timeout - (Date.now() - daily))
			};
		} else {
			UserData.wallet += Number(AMT);
			UserData.lastUsedDaily = Date.now();
			await UserData.save();
			return UserData.wallet;
		}
	}
	/**
	 * Weekly
	 * @param UserID
	 * @param GuildID
	 */

	async Weekly(UserID, GuildID) {
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A Item ID must be specified');

		let UserData = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		let GuildData = await Guildd.findOne({
			gid: GuildID
		});
		let AMT;
		if (!GuildData) {
			AMT = 10000;
		}
		if (GuildData) {
			AMT = GuildData.weeklyAmt;
		}
		let timeout = 604800000;
		if (!UserData) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID,
				wallet: Number(AMT),
				lastUsedWeekly: Date.now()
			});

			await AddUser.save();
			return AddUser.wallet;
		}
		let weekly = UserData.lastUsedWeekly;
		if (weekly !== null &amp;&amp; timeout - (Date.now() - weekly) > 0) {
			return {
				error: 'ALREADY_USED',
				timeout: _msToTime(timeout - (Date.now() - weekly))
			};
		} else {
			UserData.wallet += Number(AMT);
			UserData.lastUsedWeekly = Date.now();
			await UserData.save();
			return UserData.wallet;
		}
	}
	/**
	 * GetInv
	 * @param {String} UserID
	 * @param {String} GuildID
	 */
	async GetInv(UserID, GuildID) {
		// Required Parameters
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A guild id must be specified.');

		let User = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		if (!User) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID
			});

			await AddUser.save();

			if (!AddUser.inventory) {
				return 'NO_ITEM';
			} else {
				return AddUser.inventory;
			}
		}
		if (!User.inventory) {
			return 'NO_ITEM';
		} else {
			return User.inventory;
		}
	}

	/**
	 * GetUser
	 * @param {String} UserID
	 * @param {String} GuildID
	 */
	async GetUser(UserID, GuildID) {
		// Required Parameters
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A guild id must be specified.');

		let User = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		if (!User) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID
			});

			await AddUser.save();

			return AddUser;
		}
		return User;
	}

	/**
	 * GetBal
	 * @param {String} UserID
	 * @param {String} GuildID
	 */
	async GetBal(UserID, GuildID) {
		// Required Parameters
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A guild id must be specified.');

		let Bal = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		if (!Bal) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID
			});

			await AddUser.save();

			return AddUser.wallet;
		}
		return Bal.wallet;
	}
	/**
	 * GetItem
	 * @param Client
	 * @param {String} guildId
	 * @param {String} Item 
	 */
	async GetItem(Client, guildId, Item, options = {}) {
		if (!Item) throw new TypeError('No item name or id specified.');
		if (!Client) throw new TypeError('A discord.js client should be provided');
		let GuildData = await Guildd.findOne({
			gid: guildId
		});
		let Global = await gshop.findOne({
			Id: Client.user.id
		});

		if (options.global === true) {
		if (!guildId) throw new TypeError('A guild id must be specified.');      
			if (!Global) return null;

			return Global.shopItems.filter(item => _checkItem(item, Item))[0];
		} else if (!options.global || options.global === false) {
			if (!GuildData) return null;
			return GuildData.shopItems.filter(item => _checkItem(item, Item))[0];
		}
	}
	/**
	 * GetBankbal
	 * @param {string} UserID
	 * @param {string} GuildID
	 */
	async GetBankBal(UserID, GuildID) {
		// Required Parameters
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A guild id must be specified.');

		let Bal = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		if (!Bal) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID
			});

			await AddUser.save();

			return AddUser.bank;
		}
		return Bal.bank;
	}
	/**
	 * AddMoney
	 * @param {String} UserID
	 * @param {String} GuildID
	 * @param {number} Amt To Add
	 */

	async AddMoney(UserID, GuildID, Amt) {
		// Required Parameters
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A guild id must be specified.');
		if (!Amt) throw new TypeError('An amount of money must be specified.');

		//Find Data In DB
		let UserData = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		//Create Data If None Is Found
		if (!UserData) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID,
				wallet: Number(Amt)
			});

			await AddUser.save();

			return AddUser.wallet;
		}
		// Update Wallet
		UserData.wallet += Number(Amt);

		await UserData.save();

		return UserData.wallet;
	}

	/**
	 * RemoveMoney
	 * @param {String} UserID
	 * @param {String} GuildID
	 * @param {number} Amt To Remove
	 */

	async RemoveMoney(UserID, GuildID, Amt) {
		// Required Parameters
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A guild id must be specified.');
		if (!Amt) throw new TypeError('An amount of money must be specified.');

		//Find Data In DB
		let UserData = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		//If None Is Found
		if (!UserData) {
			return;
		}
		// Update Wallet
		UserData.wallet -= Number(Amt);

		await UserData.save();

		return UserData.wallet;
	}

	/**
	 * Rich
	 * @param {string} GuildID - The id of the guild
	 */
	async GetRich(GuildID) {
		if (!GuildID) throw new TypeError('A guild id must be specified.');

		let lb = await data
			.find({
				gid: GuildID
			})
			.sort([['wallet' + 'bank', 'descending']])
			.exec()
			.catch(e => {
				throw new TypeError(`An Error Just Occurred. ${e}`);
			});
		if (lb.length == 0) {
			return 'NO_RICH_PEOPLE';
		}
		return lb;
	}

	/**
	 * Profile
	 * @param {string} GuildID - The id of the guild
	 * @param {string} UserID - The id of the user
	 */
	async GetProfile(GuildID, UserID) {
		if (!GuildID) throw new TypeError('A guild id must be specified.');
		if (!UserID) throw new TypeError('A user id must be specified.');

		let User = await data.findOne({
			userID: UserID,
			gid: GuildID
		});

		let Profile = [];
		Profile.push({
			user: User.userID,
			wallet: User.wallet,
			job: User.job,
			bank: User.bank,
			inventory: User.inventory.length,
			salary: User.salary
		});
		return Profile;
	}

	/**
	 * Deposit
	 * @param {String} UserID
	 * @param {String} GuildID
	 * @param {number | "max"} Amt To Deposit
	 */

	async Deposit(UserID, GuildID, Amt) {
		if (!UserID) throw new SyntaxError('A member ID must be specified.');
		if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
		if (!Amt) throw new SyntaxError('An amount must be specified.');

		let Balance = await data.findOne({
			userID: UserID,
			gid: GuildID
		});

		if (!Balance) {
			Balance = await new data({
				userID: UserID,
				gid: GuildID
			});
			await Balance.save();
			return 'NO_CASH_IN_WALLET';
		}
		if (Balance.wallet &lt; Amt) {
			return 'NOT_ENOUGH_CASH';
		}
		let amt;
		if (Amt === 'max') {
			amt = Balance.wallet;
		} else {
			amt = Amt;
		}
		Balance.bank += Number(amt);
		Balance.wallet -= Number(amt);

		await Balance.save();

		return { wallet: Balance.wallet, Bank: Balance.bank };
	}
	/**
	 * Withdraw
	 * @param {String} UserID
	 * @param {String} GuildID
	 * @param {number | "max"} Amt To Withdraw
	 */

	async Withdraw(UserID, GuildID, Amt) {
		if (!UserID) throw new SyntaxError('A member ID must be specified.');
		if (!GuildID) throw new SyntaxError('A guild ID must be specified.');
		if (!Amt) throw new SyntaxError('An amount must be specified.');

		let Balance = await data.findOne({
			userID: UserID,
			gid: GuildID
		});

		if (!Balance) {
			Balance = await new data({
				userID: UserID,
				gid: GuildID
			});
			await Balance.save();
			return 'NO_CASH_IN_BANK';
		}
		if (Balance.bank &lt; Amt) {
			return 'NOT_ENOUGH_CASH';
		}

		let amt;
		if (Amt == 'max') {
			amt = Balance.bank;
		} else {
			amt = Amt;
		}
		Balance.bank -= Number(amt);
		Balance.wallet += Number(amt);

		await Balance.save();

		return { wallet: Balance.wallet, Bank: Balance.bank };
	}

	/**
	 * GetShop
	 * @param Client
	 * @param {String} GuildID
	 */
	async GetShop(Client, GuildID, options = {}) {
		// Required Parameters

		if (!GuildID) throw new TypeError('A guild id must be specified.');

		if (options.global === true || options.global === 'true') {
			let Gshop = await gshop.findOne({
				Id: Client.user.id
			});
			if (!Gshop) {
				let Ggshop = new gshop({
					Id: Client.user.id
				});

				await Ggshop.save();
				if (!gshop.shopItems) {
					return 'NO_ITEM_IN_SHOP';
				} else {
					return Ggshop.shopItems;
				}
			}
			if (!Gshop.shopItems) {
				return 'NO_ITEM_IN_SHOP';
			} else {
				return Gshop.shopItems;
			}
		} else if (
			!options.global ||
			options.global === false ||
			options.global === 'true'
		) {
			let User = await Guildd.findOne({
				gid: GuildID
			});
			if (!User) {
				let AddUser = new data({
					gid: GuildID
				});

				await AddUser.save();
				if (!AddUser.shopItems) {
					return 'NO_ITEM_IN_SHOP';
				} else {
					return AddUser.shopItems;
				}
			}
			if (!User.shopItems) {
				return 'NO_ITEM_IN_SHOP';
			} else {
				return User.shopItems;
			}
		}
	}

	/**
	 * setJob
	 * @param {string} guildId
	 * @param {string} userId
	 * @param {string} Job
	 */

	async ReassignJob(userId, guildId, Job) {
		if (!userId) throw new SyntaxError('A member ID must be specified.');
		if (!guildId) throw new SyntaxError('A guild ID must be specified.');
		if (!Job) throw new SyntaxError('An amount must be specified.');

		const user = await data.findOne({
			userID: userId,
			gid: guildId
		});
		if (!user) {
			const aa = new data({
				userID: userId,
				gid: guildId
			});
			return aa.save();
		}

		let job = jobs.find(job => job.Name === Job);

		let current = user.job;
		if (!current) {
			return 'NOT_WORKING';
		} else if (!job) {
			let Jobss = [];
			jobs.map(x => {
				Jobss.push({
					Name: x.Name,
					Salary: x.Salary
				});
			});
			return Jobss;
		} else if (job.Name) {
			user.job = job.Name;
			user.salary = job.Salary;

			await user.save();

			return 'SUCCESS';
		}
	}

	/**
	 * RemoveJob
	 * @param {string} guildId
	 * @param {string} userId
	 */

	async RemoveJob(guildId, userId) {
		if (!userId) throw new SyntaxError('A member ID must be specified.');
		if (!guildId) throw new SyntaxError('A guild ID must be specified.');

		const user = await data.findOne({ userID: userId, gid: guildId });
		if (!user) {
			const aa = new data({ userID: userId, gid: guildId });
			return aa.save();
		}

		let current = user.job;

		if (!current) {
			return 'NO_JOB';
		} else if (current) {
			user.job = null;
			await user.save();
			return 'SUCCESS';
		}
	}

	/**
	 * setJob
	 * @param {string} guildId
	 * @param {string} userId
	 * @param {string} Job
	 */

	async SetJob(userId, guildId, Job) {
		if (!userId) throw new SyntaxError('A member ID must be specified.');
		if (!guildId) throw new SyntaxError('A guild ID must be specified.');
		if (!Job) throw new SyntaxError('An amount must be specified.');

		const user = await data.findOne({
			userID: userId,
			gid: guildId
		});
		if (!user) {
			const aa = new data({
				userID: userId,
				gid: guildId
			});
			return aa.save();
		}

		let job = jobs.find(job => job.Name === Job);
		let current = user.job;
		if (current) {
			return 'ALREADY_WORKING';
		} else if (!job) {
			let Jobss = [];
			jobs.map(x => {
				Jobss.push({
					Name: x.Name,
					Salary: x.Salary
				});
			});
			return Jobss;
		} else if (job.Name) {
			user.job = job.Name;
			user.salary = job.Salary;

			await user.save();

			return 'SUCCESS';
		}
	}

	/**
	 * Work
	 * @param UserID
	 * @param GuildID
	 */

	async Work(UserID, GuildID) {
		if (!UserID) throw new TypeError('A member ID must be specified');
		if (!GuildID) throw new TypeError('A Item ID must be specified');

		let UserData = await data.findOne({
			userID: UserID,
			gid: GuildID
		});
		let AMT = UserData.salary;

		let timeout = 7200000;
		if (!UserData) {
			let AddUser = new data({
				userID: UserID,
				gid: GuildID,
				wallet: Number(AMT),
				lastUsedWork: Date.now()
			});

			await AddUser.save();
			return AddUser.wallet;
		}

		let work = UserData.lastUsedWork;
		if (!UserData.job) {
			return 'NO_JOB';
		}
		if (work !== null &amp;&amp; timeout - (Date.now() - work) > 0) {
			return {
				error: 'ALREADY_WORKED',
				timeout: _msToTime(timeout - (Date.now() - work))
			};
		} else {
			UserData.wallet += Number(AMT);
			UserData.lastUsedWork = Date.now();
			await UserData.save();
			return {
				wallet: UserData.wallet,
				timeout: _msToTime(work),
				job: UserData.job,
				salary: AMT
			};
		}
	}
}

function _msToTime(duration) {
	const ms = Math.floor((duration % 1000) / 100),
		seconds = Math.floor((duration / 1000) % 60),
		minutes = Math.floor((duration / (1000 * 60)) % 60),
		hours = Math.floor((duration / (1000 * 60 * 60)) % 24),
		days = Math.floor((duration / (1000 * 60 * 60 * 24)) % 30);

	const day = days &lt; 10 ? '0' + days : days;
	const hour = hours &lt; 10 ? '0' + hours : hours;
	const minute = minutes &lt; 10 ? '0' + minutes : minutes;
	const second = seconds &lt; 10 ? '0' + seconds : seconds;

	return (
		day + ' Days : ' + hour + ' Hrs : ' + minute + ' Min : ' + second + ' Sec.'
	);
}

const _checkItem = (item, testableItemIdOrName) => {
	return item.Name == testableItemIdOrName || item.id == testableItemIdOrName;
};

module.exports = SimplyEco;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Fri Dec 17 2021 18:31:08 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
